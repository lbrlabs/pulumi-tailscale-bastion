// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package kubernetes

import (
	"context"
	"reflect"

	"errors"
	"github.com/lbrlabs/pulumi-tailscale-bastion/sdk/go/bastion/internal"
	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/core/v1"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Bastion struct {
	pulumi.ResourceState

	// The name of the kubernetes deployment that contains the tailscale bastion
	DeploymentName pulumi.StringOutput `pulumi:"deploymentName"`
}

// NewBastion registers a new resource with the given unique name, arguments, and options.
func NewBastion(ctx *pulumi.Context,
	name string, args *BastionArgs, opts ...pulumi.ResourceOption) (*Bastion, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Routes == nil {
		return nil, errors.New("invalid value for required argument 'Routes'")
	}
	if args.TailscaleTags == nil {
		return nil, errors.New("invalid value for required argument 'TailscaleTags'")
	}
	if args.HighAvailability == nil {
		args.HighAvailability = pulumi.Bool(false)
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Bastion
	err := ctx.RegisterRemoteComponentResource("tailscale-bastion:kubernetes:Bastion", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type bastionArgs struct {
	// Whether we should create a new namespace.
	CreateNamespace bool `pulumi:"createNamespace"`
	// Whether the bastion should be highly available.
	HighAvailability bool `pulumi:"highAvailability"`
	// The bucket resource.
	Namespace *corev1.Namespace `pulumi:"namespace"`
	// The routes to advertise to tailscale. This is likely the Pod and Service CIDR.
	Routes []string `pulumi:"routes"`
	// The tags to apply to the tailnet device andauth key. This tag should be added to your oauth key and ACL.
	TailscaleTags []string `pulumi:"tailscaleTags"`
}

// The set of arguments for constructing a Bastion resource.
type BastionArgs struct {
	// Whether we should create a new namespace.
	CreateNamespace bool
	// Whether the bastion should be highly available.
	HighAvailability pulumi.BoolInput
	// The bucket resource.
	Namespace corev1.NamespaceInput
	// The routes to advertise to tailscale. This is likely the Pod and Service CIDR.
	Routes pulumi.StringArrayInput
	// The tags to apply to the tailnet device andauth key. This tag should be added to your oauth key and ACL.
	TailscaleTags pulumi.StringArrayInput
}

func (BastionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*bastionArgs)(nil)).Elem()
}

type BastionInput interface {
	pulumi.Input

	ToBastionOutput() BastionOutput
	ToBastionOutputWithContext(ctx context.Context) BastionOutput
}

func (*Bastion) ElementType() reflect.Type {
	return reflect.TypeOf((**Bastion)(nil)).Elem()
}

func (i *Bastion) ToBastionOutput() BastionOutput {
	return i.ToBastionOutputWithContext(context.Background())
}

func (i *Bastion) ToBastionOutputWithContext(ctx context.Context) BastionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BastionOutput)
}

// BastionArrayInput is an input type that accepts BastionArray and BastionArrayOutput values.
// You can construct a concrete instance of `BastionArrayInput` via:
//
//	BastionArray{ BastionArgs{...} }
type BastionArrayInput interface {
	pulumi.Input

	ToBastionArrayOutput() BastionArrayOutput
	ToBastionArrayOutputWithContext(context.Context) BastionArrayOutput
}

type BastionArray []BastionInput

func (BastionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Bastion)(nil)).Elem()
}

func (i BastionArray) ToBastionArrayOutput() BastionArrayOutput {
	return i.ToBastionArrayOutputWithContext(context.Background())
}

func (i BastionArray) ToBastionArrayOutputWithContext(ctx context.Context) BastionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BastionArrayOutput)
}

// BastionMapInput is an input type that accepts BastionMap and BastionMapOutput values.
// You can construct a concrete instance of `BastionMapInput` via:
//
//	BastionMap{ "key": BastionArgs{...} }
type BastionMapInput interface {
	pulumi.Input

	ToBastionMapOutput() BastionMapOutput
	ToBastionMapOutputWithContext(context.Context) BastionMapOutput
}

type BastionMap map[string]BastionInput

func (BastionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Bastion)(nil)).Elem()
}

func (i BastionMap) ToBastionMapOutput() BastionMapOutput {
	return i.ToBastionMapOutputWithContext(context.Background())
}

func (i BastionMap) ToBastionMapOutputWithContext(ctx context.Context) BastionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BastionMapOutput)
}

type BastionOutput struct{ *pulumi.OutputState }

func (BastionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Bastion)(nil)).Elem()
}

func (o BastionOutput) ToBastionOutput() BastionOutput {
	return o
}

func (o BastionOutput) ToBastionOutputWithContext(ctx context.Context) BastionOutput {
	return o
}

// The name of the kubernetes deployment that contains the tailscale bastion
func (o BastionOutput) DeploymentName() pulumi.StringOutput {
	return o.ApplyT(func(v *Bastion) pulumi.StringOutput { return v.DeploymentName }).(pulumi.StringOutput)
}

type BastionArrayOutput struct{ *pulumi.OutputState }

func (BastionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Bastion)(nil)).Elem()
}

func (o BastionArrayOutput) ToBastionArrayOutput() BastionArrayOutput {
	return o
}

func (o BastionArrayOutput) ToBastionArrayOutputWithContext(ctx context.Context) BastionArrayOutput {
	return o
}

func (o BastionArrayOutput) Index(i pulumi.IntInput) BastionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Bastion {
		return vs[0].([]*Bastion)[vs[1].(int)]
	}).(BastionOutput)
}

type BastionMapOutput struct{ *pulumi.OutputState }

func (BastionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Bastion)(nil)).Elem()
}

func (o BastionMapOutput) ToBastionMapOutput() BastionMapOutput {
	return o
}

func (o BastionMapOutput) ToBastionMapOutputWithContext(ctx context.Context) BastionMapOutput {
	return o
}

func (o BastionMapOutput) MapIndex(k pulumi.StringInput) BastionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Bastion {
		return vs[0].(map[string]*Bastion)[vs[1].(string)]
	}).(BastionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BastionInput)(nil)).Elem(), &Bastion{})
	pulumi.RegisterInputType(reflect.TypeOf((*BastionArrayInput)(nil)).Elem(), BastionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BastionMapInput)(nil)).Elem(), BastionMap{})
	pulumi.RegisterOutputType(BastionOutput{})
	pulumi.RegisterOutputType(BastionArrayOutput{})
	pulumi.RegisterOutputType(BastionMapOutput{})
}
